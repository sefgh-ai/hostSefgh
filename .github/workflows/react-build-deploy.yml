name: Build and Deploy React App

on:
  push:
    paths:
      - 'react/**'
  workflow_dispatch:  # Allows manual triggering

# Add permissions to allow the workflow to push to the repository
permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  cancel-previous:
    runs-on: ubuntu-latest
    steps:
      - name: Cancel Previous Runs
        uses: styfle/cancel-workflow-action@0.9.1
        with:
          access_token: ${{ github.token }}

  build-and-deploy:
    needs: cancel-previous
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          # Fetch all history for proper commits
          fetch-depth: 0
        
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18  # Using a more recent Node version
          
      - name: Set up environment
        run: |
          echo "Current date: $(date +"%Y-%m-%d %H:%M:%S")"
          echo "Node version: $(node -v)"
          echo "NPM version: $(npm -v)"
      
      - name: Analyze package dependencies
        id: analyze-deps
        run: |
          cd react
          
          # Create a diagnostic script to analyze dependencies - using .cjs extension for CommonJS
          cat > dependency-analyzer.cjs << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');
          
          // Read package.json
          const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          
          // Ensure we're not treating the project as ES modules if we need to use require
          const originalType = packageJson.type;
          if (packageJson.type === 'module') {
            delete packageJson.type;
            fs.writeFileSync('package.json', JSON.stringify(packageJson, null, 2));
            console.log('Temporarily removed "type": "module" from package.json for compatibility');
          }
          
          const allDependencies = {
            ...packageJson.dependencies || {},
            ...packageJson.devDependencies || {}
          };
          
          console.log('Analyzing dependencies for conflicts...');
          
          // Check for nested dependencies with version conflicts
          function findNestedDependencies() {
            const conflicts = {};
            
            try {
              // Run npm ls to find dependency conflicts
              const output = execSync('npm ls --json', { encoding: 'utf8' });
              const depTree = JSON.parse(output);
              
              function traverseTree(node, path = []) {
                if (!node || !node.dependencies) return;
                
                Object.keys(node.dependencies).forEach(depName => {
                  const dep = node.dependencies[depName];
                  
                  // Check if there's a version conflict
                  if (dep.problems) {
                    dep.problems.forEach(problem => {
                      if (problem.includes('peer dep missing') || problem.includes('requires a peer')) {
                        if (!conflicts[depName]) conflicts[depName] = [];
                        conflicts[depName].push({
                          path: [...path, depName].join(' > '),
                          problem: problem
                        });
                      }
                    });
                  }
                  
                  // Continue traversing
                  traverseTree(dep, [...path, depName]);
                });
              }
              
              traverseTree(depTree);
            } catch (e) {
              console.log('Error analyzing dependency tree:', e.message);
            }
            
            return conflicts;
          }
          
          // Find exact version requirements in nested dependencies
          function findNeededVersions() {
            const neededVersions = {};
            
            try {
              // Find all package.json files in node_modules
              const findCmd = execSync('find node_modules -name "package.json" | grep -v "node_modules/node_modules"', { encoding: 'utf8' });
              const packageFiles = findCmd.trim().split('\n');
              
              packageFiles.forEach(file => {
                try {
                  const pkg = JSON.parse(fs.readFileSync(file, 'utf8'));
                  
                  // Check for esbuild and other common problematic packages
                  ['esbuild', 'typescript', 'webpack', 'babel-loader', 'react', 'react-dom'].forEach(pkgName => {
                    if (pkg.dependencies && pkg.dependencies[pkgName]) {
                      const version = pkg.dependencies[pkgName];
                      if (!neededVersions[pkgName]) neededVersions[pkgName] = {};
                      neededVersions[pkgName][version] = (neededVersions[pkgName][version] || 0) + 1;
                    }
                  });
                } catch (e) {
                  // Skip invalid package.json
                }
              });
            } catch (e) {
              console.log('Error finding needed versions:', e.message);
            }
            
            return neededVersions;
          }
          
          // Update package.json with overrides/resolutions
          function updatePackageJson(conflicts, neededVersions) {
            // Initialize overrides if needed
            if (!packageJson.overrides) packageJson.overrides = {};
            
            // Add overrides for conflicting packages
            Object.keys(conflicts).forEach(pkgName => {
              packageJson.overrides[pkgName] = '*';
            });
            
            // Add specific version overrides for packages with clear version needs
            Object.keys(neededVersions).forEach(pkgName => {
              const versions = neededVersions[pkgName];
              const entries = Object.entries(versions);
              if (entries.length > 1) {
                // Find most commonly required version
                entries.sort((a, b) => b[1] - a[1]);
                const mostCommonVersion = entries[0][0];
                packageJson.overrides[pkgName] = mostCommonVersion;
                console.log(`Setting ${pkgName} to version ${mostCommonVersion} (used ${entries[0][1]} times)`);
              }
            });
            
            // Restore original type if it was set
            if (originalType) {
              packageJson.type = originalType;
            }
            
            // Write updated package.json
            fs.writeFileSync('package.json', JSON.stringify(packageJson, null, 2));
            console.log('Updated package.json with necessary overrides');
          }
          
          // Run analysis and update
          const conflicts = findNestedDependencies();
          const neededVersions = findNeededVersions();
          
          updatePackageJson(conflicts, neededVersions);
          
          // Output results for the workflow
          const results = {
            conflictCount: Object.keys(conflicts).length,
            overrideCount: Object.keys(packageJson.overrides).length
          };
          
          console.log('ANALYSIS_RESULTS=' + JSON.stringify(results));
          EOF
          
          # First attempt installation to get the dependency tree
          npm install --no-package-lock || true
          
          # Run the analyzer script with node (using CommonJS)
          node dependency-analyzer.cjs
          
      - name: Advanced dependency resolution
        run: |
          cd react
          
          # Create a smart installer script - using .cjs extension for CommonJS
          cat > smart-installer.cjs << 'EOF'
          const { execSync } = require('child_process');
          const fs = require('fs');
          
          console.log('Starting smart dependency installation...');
          
          // First pass - clean install with highest compatibility
          try {
            console.log('\n--- ATTEMPT 1: Clean install with legacy peer deps ---');
            execSync('npm install --legacy-peer-deps', { stdio: 'inherit' });
          } catch (e) {
            console.log('First install attempt failed, trying alternative approach...');
            
            try {
              console.log('\n--- ATTEMPT 2: Force install ---');
              execSync('npm install --force', { stdio: 'inherit' });
            } catch (e) {
              console.log('Second install attempt failed, trying individual packages...');
              
              try {
                const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
                const allDeps = { ...pkg.dependencies || {}, ...pkg.devDependencies || {} };
                
                console.log('\n--- ATTEMPT 3: Installing essential packages ---');
                // Install just the essential build packages
                const essentialPackages = [
                  'react', 'react-dom', 'typescript', 'esbuild', 
                  '@types/react', '@types/node', 'webpack'
                ].filter(pkg => allDeps[pkg]);
                
                if (essentialPackages.length) {
                  execSync(`npm install ${essentialPackages.join(' ')} --force`, { stdio: 'inherit' });
                }
                
                // Try to fix specific problematic packages
                console.log('\n--- Fixing common problematic packages ---');
                
                // Special case for esbuild
                try {
                  console.log('Fixing esbuild...');
                  execSync('npm install esbuild@latest --force', { stdio: 'inherit' });
                } catch (err) {}
                
                // Try to install the rest of the dependencies
                console.log('\n--- Installing remaining dependencies ---');
                execSync('npm install --legacy-peer-deps --no-package-lock', { stdio: 'inherit' });
                
              } catch (e) {
                console.log('Third installation attempt failed.');
                console.log('Dependency installation could not be completed automatically.');
                process.exit(1);
              }
            }
          }
          
          // Fix any remaining issues with problematic packages
          console.log('\n--- Fixing any remaining dependency issues ---');
          
          // Check if lovable-tagger is present and fix it
          if (fs.existsSync('node_modules/lovable-tagger')) {
            console.log('Fixing lovable-tagger...');
            try {
              // First, ensure the correct esbuild version is installed at the root
              execSync('npm install esbuild@latest --no-save', { stdio: 'inherit' });
              
              // Copy esbuild from root node_modules to lovable-tagger's node_modules
              if (!fs.existsSync('node_modules/lovable-tagger/node_modules')) {
                fs.mkdirSync('node_modules/lovable-tagger/node_modules');
              }
              
              if (!fs.existsSync('node_modules/lovable-tagger/node_modules/esbuild') && 
                  fs.existsSync('node_modules/esbuild')) {
                execSync('cp -r node_modules/esbuild node_modules/lovable-tagger/node_modules/', { stdio: 'inherit' });
                console.log('Copied esbuild to lovable-tagger modules');
              }
            } catch (err) {
              console.log('Error fixing lovable-tagger:', err.message);
            }
          }
          
          console.log('Smart installation completed!');
          EOF
          
          # Run the smart installer
          node smart-installer.cjs
          
      - name: Build React app with retry
        run: |
          cd react
          
          # Create a smart build script - using .cjs extension for CommonJS
          cat > smart-build.cjs << 'EOF'
          const { execSync } = require('child_process');
          const fs = require('fs');
          
          console.log('Starting smart build process...');
          
          // Try multiple build approaches
          const buildAttempts = [
            {
              name: 'Standard build',
              command: 'npm run build',
              env: { NODE_OPTIONS: '--max_old_space_size=4096' }
            },
            {
              name: 'Build with esbuild rebuild',
              command: 'npm rebuild esbuild && npm run build',
              env: { NODE_OPTIONS: '--max_old_space_size=4096' }
            },
            {
              name: 'Build with latest esbuild',
              command: 'npm install esbuild@latest --no-save && npm run build',
              env: { NODE_OPTIONS: '--max_old_space_size=4096' }
            },
            {
              name: 'Build with force flag',
              command: 'npm run build -- --force',
              env: { NODE_OPTIONS: '--max_old_space_size=4096' }
            }
          ];
          
          let buildSuccessful = false;
          
          for (const attempt of buildAttempts) {
            console.log(`\n--- BUILD ATTEMPT: ${attempt.name} ---`);
            
            try {
              execSync(attempt.command, { 
                stdio: 'inherit',
                env: { ...process.env, ...attempt.env }
              });
              
              // Check if build output exists
              if (fs.existsSync('dist') || fs.existsSync('build')) {
                console.log(`Build successful with: ${attempt.name}`);
                buildSuccessful = true;
                break;
              } else {
                console.log(`Build command completed but no output directory found`);
              }
            } catch (e) {
              console.log(`Build attempt failed: ${e.message}`);
            }
          }
          
          if (!buildSuccessful) {
            console.log('All build attempts failed. Build could not be completed automatically.');
            process.exit(1);
          }
          
          console.log('Smart build completed successfully!');
          EOF
          
          # Run the smart build script
          node smart-build.cjs
          
      - name: Identify build output
        id: find-output
        run: |
          cd react
          
          if [ -d "dist" ]; then
            echo "output_dir=dist" >> $GITHUB_OUTPUT
            echo "Build output found in dist directory"
          elif [ -d "build" ]; then
            echo "output_dir=build" >> $GITHUB_OUTPUT
            echo "Build output found in build directory"
          else
            # Look for any output directory as fallback
            OUTPUT_DIR=$(find . -maxdepth 1 -type d | grep -v "^\.$" | grep -v "node_modules" | grep -v ".git" | head -n 1)
            if [ -n "$OUTPUT_DIR" ]; then
              OUTPUT_NAME=$(basename "$OUTPUT_DIR")
              echo "output_dir=$OUTPUT_NAME" >> $GITHUB_OUTPUT
              echo "Build output found in $OUTPUT_NAME directory"
            else
              echo "No build output directory found"
              exit 1
            fi
          fi
          
      - name: Deploy build to repository
        run: |
          # Get the output directory from previous step
          OUTPUT_DIR="${{ steps.find-output.outputs.output_dir }}"
          
          # Backup any custom files
          mkdir -p temp_backup
          if [ -f "searchpage.html" ]; then
            cp searchpage.html temp_backup/
          fi
          
          # Remove old dist directory if exists
          rm -rf dist
          
          # Move build output to dist
          if [ -d "react/$OUTPUT_DIR" ]; then
            mv "react/$OUTPUT_DIR" ./dist
          else
            echo "Build output directory not found"
            exit 1
          fi
          
          # Restore any custom files from backup
          if [ -f "temp_backup/searchpage.html" ]; then
            if [ -f "dist/index.html" ] && [ ! -f "dist/searchpage.html" ]; then
              mv dist/index.html dist/searchpage.html
            elif [ -f "dist/index.html" ]; then
              cp temp_backup/searchpage.html dist/
            fi
          fi
          
          # Clean up backup
          rm -rf temp_backup
          
      - name: Configure Git
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
      
      - name: Commit and push changes
        run: |
          # Use the github.token for authentication with correct permissions
          git remote set-url origin https://x-access-token:${{ github.token }}@github.com/${{ github.repository }}.git
          
          # Stage all changes in dist directory
          git add dist
          
          # Commit the changes
          git commit -m "Update built React app [$(date +"%Y-%m-%d %H:%M:%S")]" || echo "No changes to commit"
          
          # Push with verbose output to help debugging
          git push --verbose || {
            echo "Push failed, trying to pull first"
            git pull --rebase origin $(git rev-parse --abbrev-ref HEAD)
            git push --verbose
          }

      - name: Setup Pages
        uses: actions/configure-pages@v3

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v2
        with:
          artifact_name: github-pages
